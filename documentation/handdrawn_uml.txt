@startuml
skinparam linetype ortho


package Soot {
	class SceneBuilder {
	}
	class SootClass{
	}
}

package App {
	class Runner {
	  + {static} void main(String[])
	}
	class PropertiesSetter{
	  - String propfile
	  - String[] cliArgs;
	  + PropertiesSetter(String propfile, String[] cliArgs)
	  - void setSystemProperties()
	}
	
	class Processor {
	  - List<Analyzer> pipeline
	  - AnalyzerBundle bundle
	  + AnalyzerBundle executePipeline()
	}
}

package Analyzer {
	abstract Analyzer {
	  ~ List<Filter> filters
	  ~ AnalyzerBundle bundle
	  + Analyzer(List<Filter> filters)
	  + {abstract} AnalyzerBundle execute(AnalyzerBundle)
	  + void addFilter(Filter)
	  # boolean passesFilters(SootClass)
	  # boolean passesFilters(SootMethod)
	  # boolean passesFilters(SootField)
	}

	class AnalyzerBundle {
	  + Map<String, Object> bundle
	  + List<SootClass> classes
	  + List<Relationship> relationships
	  + List<Message> messages
	  + List<Pattern> patterns
	  + Scene scene
	}

	class SootAnalyzer extends Analyzer {
	}

	class InheritanceAnalyzer extends Analyzer {
	  - void generateExtendsRelationships(SootClass,List<Relationship>)
	  - void generateImplementsRelationships(SootClass,List<Relationship>)
	}

	class AssociationAnalyzer extends Analyzer {
	}

	class DependencyAnalyzer extends Analyzer {
	}

	class SequenceAnalyzer extends Analyzer {
	  + SequenceAnalyzer(MethodResolver methodResolver)
	}

	class AncestorAnalyzer extends Analyzer {
	}
	class UMLAnalyzer extends Analyzer {
	  +  UMLAnalyzer(Map<String, Class ? extends PatternRenderer> renderers)
	}
	class SceneAnalyzer extends Analyzer {
	}
	class DIPAnalyzer extends Analyzer {
	}
	
	class UMLParser {
	  + {static} String parse(SootClass)
	  + {static} String parse(SootField)
	  + {static} String parse(SootMethod)
	  + {static} String parse(Type)
	  + {static} String parse(Relationship)
	  + {static} String parse(Relation)
	  + {static} String trimQualifiedName(String)
	  + {static} String getAccessModifier(int)
	  + {static} String getStaticAbstractModifier(int)
	  + {static} String getClassType(int)
	}		
}

package Filters {
	interface Filter {
		+ {abstract} boolean shouldProcess(SootClass)
		+ {abstract} boolean shouldProcess(SootMethod)
		+ {abstract} boolean shouldProcess(SootField)
	}
	class PackagePrivateFilter implements Filter{
	}
	class PublicFilter implements Filter{
	}
	class ProtectedFilter implements Filter{
	}
	class DollarSignFilter implements Filter{
	}
	class ClinitFilter implements Filter{
	}
	class RelationshipFilter implements Filter{
	  - AnalyzerBundle bundle 
	  + @Inject RelationshipFilter(AnalyzerBundle bundle)
	}
	
	class ClassNameFilter implements Filter{	  
	}
	
	class JDKFilter implements Filter{
	}
}

package Models {
	enum Relation {
	  + {static} Relation ASSOCIATION
	  + {static} Relation EXTENDS
	  + {static} Relation IMPLEMENTS
	  + {static} Relation DEPENDENCY
	}
	class Relationship {
	  - SootClass from
	  - SootClass to
	  - Relation relation
	  - int cardinality
	  + void Relationship(SootClass,Relation,SootClass,int)
	}
	class ReturnMessage extends Message{
	  - String returnType
	}
	abstract Message {
	  - SootClass methodCallingClass
	  - SootMethod method
	  + {abstract} getPlantUMLString()
	}
	class CallMessage extends Message{
	  - String parameters
	}
	class CommentedOutMessage extends Message {
	  -String parameters
	}
	
	class Pattern {
	  +  SetMultimap<String, Relationship> relationships
	  +  SetMultimap<String, SootClass> classes
	  +  String name
	}
}

package Renderers {
	interface PatternRenderer {
	  + String render(Pattern pattern)
	}
}

package MethodResolution {
	interface Algorithm {
	  + List<SootMethod> resolve(Unit u, Scene scene)
	}
	
	class HierarchyAlgorithm implements Algorithm {
	}
	class CallGraphAlgorithm implements Algorithm {
	}

	abstract MethodResolver {
	  # List<Algorithm> algorithms
	
	  + MethodResolver(List<Algorithm> algorithms)
	  + {abstract} List<SootMethod> resolve(Unit u, Scene scene)
	}
	class SingleMethodResolver extends MethodResolver {
		+ List<SootMethod> resolve(Unit u, Scene scene)
	}
}

package Modules {
	class PipelineModule {
	  + {abstract} @Provides @Named("analyzers") List<Analyzer> getUserAnalyzers()
	  + @Provides @Named("Resolution") MethodResolver getMethodResolver() 
	  + @Provides @Named("pipeline") List<Analyzer> getPipeline(@Named("analyzers") Queue<Analyzers> userAnalyzers)
	  + @Provides @Named("renderers") Map<String, Class <? extends PatternRenderer>> getRenderers()
	}
	
}

package SomeoneElsesProject{
	class IntersectionMethodResolver extends MethodResolver {
	  + List<SootMethod> resolve(Unit u, Scene scene)
	}
	class ChainMethodResolver extends MethodResolver {
	  + List<SootMethod> resolve(Unit u, Scene scene)
	}
	class UnionMethodResolver extends MethodResolver {
	  + List<SootMethod> resolve(Unit u, Scene scene)
	}
}

'-----------------App relationships----------------
Runner ..> PropertiesSetter
Runner ..> Processor
Processor --> AnalyzerBundle
Processor --> Analyzer
'---------------------------------------------------

'----------------Analyzer relationships-------------
Analyzer --> Filter
Analyzer --> AnalyzerBundle
AnalyzerBundle --> Relationship
AnalyzerBundle --> Message
InheritanceAnalyzer ..> Relationship
AssociationAnalyzer ..> Relationship
DependencyAnalyzer ..> Relationship
SceneAnalyzer ..> SceneBuilder
SequenceAnalyzer ..> UMLParser
SequenceAnalyzer --> MethodResolver
UMLAnalyzer ..> UMLParser
UMLAnalyzer ..> Pattern
UMLAnalyzer ..> PatternRenderer
UMLParser ..> Relationship
UMLParser ..> Relation
'---------------------------------------------------

'----------------Filter Relationships---------------
RelationshipFilter --> AnalyzerBundle
'---------------------------------------------------

'-----------------Model Relationships---------------
Relationship --> Relation
'---------------------------------------------------


@enduml